#!/usr/bin/perl -w
use strict;
use Getopt::Long;
use Scalar::Util qw(looks_like_number);

# a generic parser for tabulated BLAST results

my $file;			# the BLAST tabulated results file (generated by using -outfmt 7)
my $out;			# the output file for the filtered list
my $with_unaln;			# output queries that has no mapping results as well
my $only_best;			# only output the first entry for each query
my $filter_col;			# the column to be used as the filter
my $sort_col;			# the column to be used as the sorting
my $criterion;			# the criterion for the filtering
my $value;			# the value to be appled to the criterion
my $ascending_sort;		# sort in an ascending order
my $desending_sort;		# sort in an desending order

GetOptions (
  "file=s" => \$file,
  "out=s" => \$out,
  "unalign" => \$with_unaln,
  "filter-col=i" =>\$filter_col,
  "criterion=s" => \$criterion,
  "value=s" => \$value,
  "best" => \$only_best,
  "sort-col=i" => \$sort_col,
  "sort-asc" => \$ascending_sort,
  "sort-des" => \$desending_sort
) or die("Error in command line arguments\n");

# print help information
if(!defined $file || !defined $out)  {
  print "\n";  
  print "ParseTabBLASTResults.pl: A general-purpose parser/filter for BLAST suite data\n";
  print "Usage: perl ParseTabBLASTReuslts.pl --file=[RESULT_FILE] --out=[OUTPUT_FILE]\n";
  print "	--file:		the BLAST results to be parsed (expected to be generated using \'-outfmt 7\')\n";
  print "	--out:		the output file\n";
  print "	--unalign:	include unaligned queries in the output\n";
  print "	--filter-col:	the column whose value to be used for filtering (0-based)\n";
  print "	--criterion:	the criterion used for filtering, use one of the following values:\n";
  print "				EQ: equal; NE: not equal; GT: greater;\n";
  print "				LT: less; GE: greater or equal; LE: less or equal\n";
  print "	--value:	the value to be applied to the criterion\n";
  print "	--best:		print the best hit only (default sort with BLAST E-value)\n";
  print "				or can be defined by sorting options of the program\n";
  print "	--sort-col:	the column to be sorted on\n";
  print "	--sort-asc:	sort the column in ascending order\n";
  print "	--sort-des:	sort the column in desending order\n";
  print "\n";
  exit;
}

# checks for incompatibility
open my $OUT, ">$out" or die "Cannot create file for output. :$!\n";
if(defined $criterion && !($criterion eq "EQ" || $criterion eq "NE" || $criterion eq "GT" ||
   $criterion eq "LT" || $criterion eq "GE" || $criterion eq "LE")
)  {
  print "Invalid setting for option \'--criterion\' (must be one of EQ, NE, GT, LT, GE, or LE). Abort.\n";
  exit;
}
if((defined $filter_col || defined $criterion || defined $value) && 
   (!(defined $filter_col) || !(defined $criterion) || !(defined $value))
)  {
  print "Information lacking: filtering requested but either column ID, criterion or value is missing. Abort.\n";
  print "\'--filter-col\', \'--criterion\', \'--value\' must all be set or all NOT be set.\n";
  exit;
}
if(defined $sort_col && !(defined $ascending_sort || defined $desending_sort))  {
  print "Information lacking: sorting requested but sorting order missed (try using \'--sort-asc\' or \'--sort-des\'). Abort.\n";
  exit;
}
if(!(defined $sort_col) && (defined $ascending_sort || defined $desending_sort))  {
  print "Information lacking: sorting requested but column ID missed (try using \'--sort-col\'). Abort.\n";
  exit;
}
if(defined $ascending_sort && defined $desending_sort)  {
  print "Conflicting definition: either one of ascending or desending sort can be used\n";
  exit;
}

# reads in all information in the file
my %contents;
my %unaligned;
my $num_cols = 0;
open my $IN, "<$file" or die "Cannot open file: $!\n";
my $q_name;
my @aln_info;
while(<$IN>)  {
  chomp;
  if(/\# Query\: (\S+)/)  {
    # alignment results of a new query begins
    my $new_q_name = $1;
    if(defined $q_name && scalar(@aln_info) == 0)  {
      $unaligned{$q_name} = 1;
    }  elsif(defined $q_name && scalar(@aln_info) > 0)  {
      @{$contents{$q_name}} = @aln_info;
      undef @aln_info;
    }
    $q_name = $new_q_name;
  }  elsif(/\#/)  {
    # other information sections, ignore them
    next;
  }  else  {
    # actual alignment results
    my @decom = split /\s+/, $_;
    if($num_cols > 0 && $num_cols != scalar(@decom))  {
      # imcompatible file or corrupted file, abort
      #print "$_\n";
      #print "Warning: Incompatible number of columns, the file may be corrupted. Abort.\n";
      next;
    }
    $num_cols = scalar(@decom);
    push @aln_info, \@decom;
  }
}
if(defined $q_name && scalar(@aln_info) == 0)  {
  $unaligned{$q_name} = 1;
}  elsif(defined $q_name && scalar(@aln_info) > 0)  {
  @{$contents{$q_name}} = @aln_info;
}
close $IN;

# check setting of column IDs
if(defined $filter_col && ($filter_col < 0 || $filter_col >= $num_cols))  {
  print "Invalid setting of the column ID used for sorting (\'--filter-col\'). Abort.\n";
  exit;
}
if(defined $sort_col && ($sort_col < 0 || $sort_col >= $num_cols))  {
  print "Invalid setting of the column ID used for sorting (\'--sort-col\'). Abort.\n";
  exit;
}

# print unaligned results, if requested
if(defined $with_unaln)  {
  foreach(sort keys %unaligned)  {
    print $OUT "$_	";
    for(my $k = 0; $k < $num_cols - 2; ++ $k)  {
      print $OUT "NA	";
    }
    print $OUT "NA\n";
  }
}

# sorting the alignment entries of each query

if(defined $sort_col && (defined $ascending_sort || defined $desending_sort))  {
  foreach(keys %contents)  {
    my $k = $_;
    if(looks_like_number(${$contents{$k}}[0][$sort_col]))  {
      @{$contents{$k}} = sort {$a->[$sort_col] <=> $b->[$sort_col]} @{$contents{$k}} if defined($ascending_sort);
      @{$contents{$k}} = sort {$b->[$sort_col] <=> $a->[$sort_col]} @{$contents{$k}} if defined($desending_sort);
    }  else  {
      @{$contents{$k}} = sort {$a->[$sort_col] cmp $b->[$sort_col]} @{$contents{$k}} if defined($ascending_sort);
      @{$contents{$k}} = sort {$b->[$sort_col] cmp $a->[$sort_col]} @{$contents{$k}} if defined($desending_sort);
    }
  }
}

# filter and print the results
sub is_satisfied($$$)  {
  my $c = shift;
  my $v = shift;
  my $s = shift;
  if(looks_like_number($s))  {
    return 1 if(($c eq "EQ" && $s == $v) ||
                ($c eq "NE" && $s != $v) ||
                ($c eq "GT" && $s > $v) ||
                ($c eq "LT" && $s < $v) ||
                ($c eq "GE" && $s >= $v) ||
                ($c eq "LE" && $s <= $v)
               );
  } else  {
    return 1 if(($c eq "EQ" && $s eq $v) ||
                ($c eq "NE" && $s ne $v) ||
                ($c eq "GT" && $s gt $v) ||
                ($c eq "LT" && $s lt $v) ||
                ($c eq "GE" && $s ge $v) ||
                ($c eq "LE" && $s le $v)
               );
  }
  return 0;
}
foreach(keys %contents)  {
  my $k = $_;
  my $num_good = 0;
  for(my $i = 0; $i < scalar(@{$contents{$k}}); ++ $i)  {
    if((!(defined $filter_col) || !(defined $criterion) || !(defined $value)) || 
        is_satisfied($criterion, $value, ${$contents{$k}}[$i][$filter_col])
    )  {
      for(my $j = 0; $j < scalar(@{${$contents{$k}}[$i]}) - 1; ++ $j)  {
        print $OUT "${$contents{$k}}[$i][$j]	";
      }
      print $OUT "${$contents{$k}}[$i][-1]\n";
      ++ $num_good;
    }
    if(defined $only_best && $num_good > 0)  {
      # quit printing if only the best is required
      last;
    }
  }
}
