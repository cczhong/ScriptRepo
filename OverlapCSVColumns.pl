#!/usr/bin/perl -w
use strict;
use Getopt::Long;

my $file1;			# the first file
my $file2;			# the second file
my $col1;			# the column IDs in the first file, separated by ','
my $col2;			# the column IDs in the second file, separated by ','
my $pre1;			# the append prefix strings for the first file, separated by ','
my $pre2;			# the append prefix strings for the second file, separated by ','
my $suf1;			# the append suffix strings for the first file, separated by ','
my $suf2;			# the append suffix strings for the second file, separated by ','
my $out;			# the output file for the statistics
my $connecter = "_";		# the string used to connect the columns
my $add_key = 0;		# whether to add key while print the results
my $mode = 0;			# the output mode
my $help = 0;			# print help information

GetOptions (
  "f1=s" => \$file1,
  "f2=s" => \$file2,
  "c1=s" => \$col1,
  "c2=s" => \$col2,
  "pre1=s" => \$pre1,
  "pre2=s" => \$pre2,
  "suf1=s" => \$suf1,
  "suf2=s" => \$suf2,
  "out=s" => \$out,
  "mode=i" => \$mode,
  "connecter=s" => \$connecter,
  "addkey" => \$add_key,
  "help" => \$help
) or die("Error in command line arguments\n");

# print help information
if($help || !defined $file1 || !defined $file2 || 
  !defined $col1 || !defined $col2 || 
  ($mode < -2 || $mode > 2)
)  {
  print "Function: Overlapping two columns in two files.\n";  
  print "Usage: perl OverlapCSVColumns.pl --f1=[FILE1] --c1=[COLUMN_ID1] --f2=[FILE2] --c2=[COLUMN_ID2]\n";
  print "	--f1: 		the first file\n";
  print "	--f2:		the second file\n";
  print "	--c1:		the column IDs (0-based) in the first file, separated by ','\n";
  print "			  Example: \"0,3,4\" means the unique key will be generated by\n";
  print "			  concatenating the 0th, 3rd, and 4th column using the connecter.\n";
  print "	--c2:		the column IDs (0-based) in the second file, separated by ','\n";
  print "	--pre1:		the strings to be appended as prefixes for columns in file1\n";
  print "			  Example: \"chr,,\" to append \"chr\"\n";
  print "			  to the first column as indicated by c1 (in this case 0)\n";
  print "	--pre2:		the strings to be appended as prefixes for columns in file2\n";
  print "	--suf1:		the strings to be appended as suffixes for columns in file1\n";
  print "	--suf2:		the strings to be appended as suffixes for columns in file2\n";
  print "	--connecter:	the connecter used to concatenate the columns\n";
  print "	--addkey:	also outputing the reconstructed key\n";
  print "	--mode:		the output mode\n";
  print "			  0: summary statistics\n";
  print "			  1: overlapped entries in f1\n";
  print "			  2: non-overlapped entries in f1\n";
  print "			  -1: overlapped entries in f2\n";
  print "			  -2: non-overlapped entries in f2\n";
  print "	--out:		the file that output the results (optional)\n";
  print "	--help:		print this help information\n";
  exit;
}

if(defined $out)  {
  open my $OUT, ">$out" or die "Cannot create file for output <$out>: $!\n";
  close $OUT;
}

my %f1_entries;
my %common_entries;
my %f2_entries;

# check input consistency
sub SplitWithEmpty($$)  {
  my $string = shift;
  my $delim = shift;
  my @out;
  my $prev = -length($delim);
  my $current;
  for(my $i = 0; $i < length($string); ++ $i)  {
    my $mer = substr($string, $i, length($delim));
    if($mer eq $delim)  {
      push @out, substr($string, $prev + length($delim), $i - $prev - length($delim));
      $prev = $i;
    }
  }
  push @out, substr($string, $prev + length($delim), length($string) - $prev - length($delim));
  return @out;
}
my @col1_ids = split /\,/, $col1;
die "No column in file1 specified!\n" if (scalar @col1_ids <= 0);
my @col2_ids = split /\,/, $col2;
die "No column in file2 specified!\n" if (scalar @col2_ids <= 0);
die "Num. of columns in file1 and file2 do not match!\n" if(scalar @col1_ids != scalar @col2_ids);
my @foo;
foreach(@col1_ids)  {
  push @foo, "";
}
my @prefix1 = @foo;
my @prefix2 = @foo;
my @suffix1 = @foo;
my @suffix2 = @foo;
@prefix1 = SplitWithEmpty($pre1, ',') if defined $pre1;
@prefix2 = SplitWithEmpty($pre2, ',') if defined $pre2;
@suffix1 = SplitWithEmpty($suf1, ',') if defined $suf1;
@suffix2 = SplitWithEmpty($suf2, ',') if defined $suf2;
die "Num. of prefix columns does not match the key columns in file1!\n" 
  if (defined $pre1 and scalar @prefix1 != scalar @col1_ids);
die "Num. of prefix columns does not match the key columns in file2!\n"
  if (defined $pre2 and scalar @prefix2 != scalar @col2_ids);
die "Num. of suffix columns does not match the key columns in file1!\n"
  if (defined $suf1 and scalar @suffix1 != scalar @col1_ids);
die "Num. of suffix columns does not match the key columns in file2!\n"
  if (defined $suf2 and scalar @suffix2 != scalar @col2_ids);

# process the first file
open my $IN1, "<$file1" or die "Cannot open file: $!\n";
while(<$IN1>)  {
  chomp;
  next if /^\#/;	# remove comments
  my $line = $_;
  my @decom = split /\s+/, $line;
  my $key = "";
  foreach(my $i = 0; $i < scalar(@col1_ids); ++ $i)  {
    if(scalar @decom < $col1_ids[$i] + 1)  {
      die "The input file: column ID overflow in $file1 <$col1_ids[$i]>, please check input\n";
    }  else  {
      $key .= $prefix1[$i] . $decom[$col1_ids[$i]] . $suffix1[$i] . $connecter;
    }
  }
  $f1_entries{$key} = $line;
}
close $IN1;

# process the second file
open my $IN2, "<$file2" or die "Cannot open file: $!\n";
while(<$IN2>)  {
  chomp;
  next if /^\#/;        # remove comments
  my $line = $_;
  my @decom = split /\s+/, $line;
  my $key = "";
  foreach(my $i = 0; $i < scalar(@col2_ids); ++ $i)  {
    if(scalar @decom < $col2_ids[$i] + 1)  {
      die "The input file: column ID overflow in $file2 <$col2_ids[$i]>, please check input\n";
    }  else  {
      $key .= $prefix2[$i]. $decom[$col2_ids[$i]] . $suffix2[$i] . $connecter;
    }
  }
  $f2_entries{$key} = $line;
}
close $IN2;

# find the overlaps
foreach(keys %f1_entries)  {
  $common_entries{$_} = 1 if exists $f2_entries{$_};
}

# define the count
my $num_cm = scalar(keys %common_entries);
my $num_f1 = scalar(keys %f1_entries) - $num_cm;
my $num_f2 = scalar(keys %f2_entries) - $num_cm;

# generate output according to modes
my @to_print;
if($mode == 0)  {
  push @to_print, "# statistics: F1_unique=$num_f1, F2_unique=$num_f2, Common=$num_cm";  
}  elsif($mode == 1)  {
  foreach(sort keys %common_entries)  {
    if($add_key)  {
      push @to_print, "$_	$f1_entries{$_}";
    }  else  {
      push @to_print, "$f1_entries{$_}";
    }
  }
}  elsif($mode == -1)  {
  foreach(sort keys %common_entries)  {
    if($add_key)  {
      push @to_print, "$_	$f2_entries{$_}";
    }  else  {
      push @to_print, "$f2_entries{$_}";
    }
  }
}  elsif($mode == 2)  {
  foreach(sort keys %f1_entries)  {
    if($add_key)  {
      push @to_print, "$_	$f1_entries{$_}" if (!exists $common_entries{$_});
    }  else  {
      push @to_print, "$f1_entries{$_}" if (!exists $common_entries{$_});
    }
  }
}  elsif($mode == -2)  {
  foreach(sort keys %f2_entries)  {
    if($add_key)  {
      push @to_print, "$_	$f2_entries{$_}" if (!exists $common_entries{$_});
    }  else  {
      push @to_print, "$f2_entries{$_}" if (!exists $common_entries{$_});
    }
  }
}

# output results
if(defined $out)  {
  open my $OUT, ">$out" or die "Cannot create file for output <$out>: $!\n";
  foreach(@to_print)  {
    print $OUT "$_\n";
  }
  close $OUT;
}  else  {
  foreach(@to_print)  {
    print "$_\n";
  }
}
